# -*- coding: utf-8 -*-
"""Analisis_ImagenTumor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FsD-UGOUfG2bOrrHizII_bDf8o6kzJfR
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sklearn
from sklearn.model_selection import train_test_split, cross_val_score
from skimage import io
from skimage import transform

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
from __future__ import absolute_import, division, print_function, unicode_literals

# Install TensorFlow
try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass

import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as pltvola

df = pd.read_csv("/labels.csv")

direc = "/imagenes/*.png"
imgs= []
col = io.imread_collection(direc)
for i in range(len(col)):
    z = transform.resize(col[i],[150,150,1])
    imgs.append((z))

lista=[]
for i in range(len(imgs)):
  img= imgs[i]
  max=img[...].max()
  lista.append(max)
print(np.max(lista))

io.imshow(imgs[0],cmap="gray")

df["image"] = imgs
hemorragia = df.iloc[:,1]
hemorragia = np.asarray(hemorragia).astype(np.float64)
x_train, x_test, y_train, y_test = train_test_split(df["image"], hemorragia, test_size = 0.2, random_state=2)

type(x_train)
x_train = x_train.tolist()
x_test = x_test.tolist()

type(x_train)
x_train = np.asarray(x_train)
x_test = np.asarray(x_test)

x_train = x_train.reshape(160, 150, 150, 1)
x_test = x_test.reshape(40, 150, 150, 1)
print("Training matrix shape", x_train.shape)
print("Testing matrix shape", x_test.shape)

"""# Modelo MLP convolucional


"""

cnn_model = tf.keras.Sequential([

        tf.keras.layers.Conv2D(filters=24, kernel_size=(3,3), input_shape=(150,150,1), activation=tf.nn.relu,name='ConvLayer01'),

        tf.keras.layers.MaxPool2D(pool_size=(2,2), strides=2,padding='valid'),
        tf.keras.layers.Dropout(0.2),

        tf.keras.layers.Conv2D(filters=24, kernel_size=(3,3)),
        tf.keras.layers.MaxPool2D(pool_size=(2,2), strides=2,padding='valid'),
        tf.keras.layers.Dropout(0.2),

        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(128, activation="relu"),
        tf.keras.layers.Dropout(0.2),

        tf.keras.layers.Dense(2, activation='softmax')
    ])

cnn_model.summary()

cnn_model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'],)

cnn_model.fit(x_train, y_train, epochs=1)

cnn_model.evaluate(x_test,  y_test, verbose=2)

# The predict_classes function outputs the highest probability class
# according to the trained classifier for each input example.
predicted_classes = cnn_model.predict_classes(x_test)

# Check which items we got right / wrong
correct_indices = np.nonzero(predicted_classes == y_test)[0]

incorrect_indices = np.nonzero(predicted_classes != y_test)[0]

plt.figure()
for i, correct in enumerate(correct_indices[:9]):
    plt.subplot(3,3,i+1)
    plt.imshow(x_test[correct].reshape(150,150), cmap='gray', interpolation='none')
    plt.title("Predicted {}, Class {}".format(predicted_classes[correct], y_test[correct]))

plt.tight_layout()

plt.figure()
for i, incorrect in enumerate(incorrect_indices[:9]):
    plt.subplot(3,3,i+1)
    plt.imshow(x_test[incorrect].reshape(150,150), cmap='gray', interpolation='none')
    plt.title("Predicted {}, Class {}".format(predicted_classes[incorrect], y_test[incorrect]))

plt.tight_layout()

"""# Modelo de MLP secuencial"""

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(150, 150,1)),
  tf.keras.layers.Dense(100, activation='relu'),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(2, activation='softmax')
])
model.summary()

model.compile(optimizer='Adamax',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Definicion del callback para Tensorboard.
logdir = os.path.join("logs", datetime.now().strftime("%Y%m%d-%H%M%S"))
tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir, histogram_freq=1)

model.fit(x_train, y_train, epochs=5,callbacks=[tensorboard_callback])

model.evaluate(x_test,  y_test, verbose=2)